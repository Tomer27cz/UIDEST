def new_scramble_algorithm(operation_type="Encode", output_type="PNG", image_path='image.png', folder_path="", output_name="output", seed=69, size=10):
    random.seed(seed)

    try:
        im = Image.open(image_path)
    except FileNotFoundError:
        return "File not found."

    block_list = []

    width, height = im.size
    blocks = [(x, y, x + size, y + size) for x in range(0, width, size) for y in range(0, height, size)]

    comparison_list = list(range(0, len(blocks)))
    random.shuffle(comparison_list)

    for iteration in range(len(blocks)):
        block = im.crop(blocks[iteration])
        block_list.append(block)

    new_image = Image.new("RGB", (width, height))

    if operation_type == 'Encode':
        for iteration in range(len(blocks)):
            new_image.paste(block_list[comparison_list[iteration]], blocks[iteration][0:2])
    else:
        for iteration in range(len(blocks)):
            new_image.paste(block_list[comparison_list.index(iteration)], blocks[iteration][0:2])

    try:
        path = folder_path + output_name + "." + output_type.lower()
        new_image.save(path, output_type)
        return f"Success."
    except FileNotFoundError:
        new_image.save(output_name, output_type)
        return "Success. (Folder not found. Image saved in program folder.)"


def make_folder(folder_path):
    # Example folder path: "C:/Users/Tomer27cz/Desktop/Files/CODING/Python Projects/AICode/Output"
    try:
        os.mkdir(folder_path)
        return folder_path
    except FileExistsError:
        if folder_path[-1] == ")":
            number = folder_path.split("(")[-1].split(")")[0]
            return make_folder(folder_path[:-3] + f"({int(number) + 1})")
        else:
            return make_folder(folder_path + " (1)")


class Steganography:

    BLACK_PIXEL = (0, 0, 0)

    def _int_to_bin(self, rgb):
        if len(rgb) == 4: r, g, b, a = rgb
        else: r, g, b = rgb
        return f'{r:08b}', f'{g:08b}', f'{b:08b}'

    def _bin_to_int(self, rgb):
        r, g, b = rgb
        return int(r, 2), int(g, 2), int(b, 2)

    def _merge_rgb(self, rgb1, rgb2):
        r1, g1, b1 = self._int_to_bin(rgb1)
        r2, g2, b2 = self._int_to_bin(rgb2)
        rgb = r1[:4] + r2[:4], g1[:4] + g2[:4], b1[:4] + b2[:4]
        return self._bin_to_int(rgb)

    def _unmerge_rgb(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[4:] + '0000', g[4:] + '0000', b[4:] + '0000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb2(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[:4] + '0000', g[:4] + '0000', b[:4] + '0000'
        return self._bin_to_int(new_rgb)

    def merge(self, image1, image2):
        # Check the images dimensions
        if image2.size[0] > image1.size[0] or image2.size[1] > image1.size[1]:
            raise ValueError('Image 2 should be smaller than Image 1!')

        # Get the pixel map of the two images
        map1 = image1.load()
        map2 = image2.load()

        new_image = Image.new(image1.mode, image1.size)
        new_map = new_image.load()

        for i in range(image1.size[0]):
            for j in range(image1.size[1]):
                is_valid = lambda: i < image2.size[0] and j < image2.size[1]
                rgb1 = map1[i ,j]
                rgb2 = map2[i, j] if is_valid() else self.BLACK_PIXEL
                new_map[i, j] = self._merge_rgb(rgb1, rgb2)

        return new_image

    def unmerge(self, image):
        pixel_map = image.load()

        # Create the new image and load the pixel map
        new_image = Image.new(image.mode, image.size)
        new_map = new_image.load()
        new_image2 = Image.new(image.mode, image.size)
        new_map2 = new_image2.load()

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map[i, j] = self._unmerge_rgb(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map2[i, j] = self._unmerge_rgb2(pixel_map[i, j])

        return [new_image, new_image2]


class Steganography3:

    BLACK_PIXEL = (0, 0, 0)

    def _int_to_bin(self, rgb):
        if len(rgb) == 4: r, g, b, a = rgb
        else: r, g, b = rgb
        return f'{r:08b}', f'{g:08b}', f'{b:08b}'

    def _bin_to_int(self, rgb):
        r, g, b = rgb
        return int(r, 2), int(g, 2), int(b, 2)

    def _merge_rgb(self, rgb1, rgb2, rgb3):
        r1, g1, b1 = self._int_to_bin(rgb1)
        r2, g2, b2 = self._int_to_bin(rgb2)
        r3, g3, b3 = self._int_to_bin(rgb3)
        rgb = r1[:4] + r2[:2] + r3[:2], g1[:4] + g2[:2] + g3[:2], b1[:4] + b2[:2] + b3[:2]
        print(b1[:4] + b2[:2] + b3[:2])
        print(b1[:4], b2[:2], b3[:2])
        return self._bin_to_int(rgb)

    def _unmerge_rgb1(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[:4] + '0000', g[:4] + '0000', b[:4] + '0000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb2(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[4:6] + '000000', g[4:6] + '000000', b[4:6] + '000000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb3(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[6:] + '000000', g[6:] + '000000', b[6:] + '000000'
        return self._bin_to_int(new_rgb)

    def merge(self, image1, image2, image3):
        # Check the images dimensions
        if image2.size[0] > image1.size[0] or image2.size[1] > image1.size[1]:
            raise ValueError('Image 2 should be smaller than Image 1!')
        if image3.size[0] > image1.size[0] or image3.size[1] > image1.size[1]:
            raise ValueError('Image 3 should be smaller than Image 1!')

        # Get the pixel map of the two images
        map1 = image1.load()
        map2 = image2.load()
        map3 = image3.load()

        new_image = Image.new(image1.mode, image1.size)
        new_map = new_image.load()

        for i in range(image1.size[0]):
            for j in range(image1.size[1]):
                is_valid = lambda: i < image2.size[0] and j < image2.size[1]
                is_valid2 = lambda: i < image3.size[0] and j < image3.size[1]
                rgb1 = map1[i, j]
                rgb2 = map2[i, j] if is_valid() else self.BLACK_PIXEL
                rgb3 = map3[i, j] if is_valid2() else self.BLACK_PIXEL
                new_map[i, j] = self._merge_rgb(rgb1, rgb2, rgb3)

        return new_image

    def unmerge(self, image):
        pixel_map = image.load()

        # Create the new image and load the pixel map
        new_image = Image.new(image.mode, image.size)
        new_map = new_image.load()
        new_image2 = Image.new(image.mode, image.size)
        new_map2 = new_image2.load()
        new_image3 = Image.new(image.mode, image.size)
        new_map3 = new_image3.load()

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map[i, j] = self._unmerge_rgb1(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map2[i, j] = self._unmerge_rgb2(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map3[i, j] = self._unmerge_rgb3(pixel_map[i, j])

        return [new_image, new_image2, new_image3]



class Steganography4:

    BLACK_PIXEL = (0, 0, 0)

    def _int_to_bin(self, rgb):
        if len(rgb) == 4: r, g, b, a = rgb
        else: r, g, b = rgb
        return f'{r:08b}', f'{g:08b}', f'{b:08b}'

    def _bin_to_int(self, rgb):
        r, g, b = rgb
        return int(r, 2), int(g, 2), int(b, 2)

    def _merge_rgb(self, rgb1, rgb2, rgb3, rgb4):
        r1, g1, b1 = self._int_to_bin(rgb1)
        r2, g2, b2 = self._int_to_bin(rgb2)
        r3, g3, b3 = self._int_to_bin(rgb3)
        r4, g4, b4 = self._int_to_bin(rgb4)
        rgb = r1[:2] + r2[:2] + r3[:2] + r4[:2], g1[:2] + g2[:2] + g3[:2] + g4[:2], b1[:2] + b2[:2] + b3[:2] + b4[:2]
        return self._bin_to_int(rgb)

    def _unmerge_rgb1(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[:2] + '000000', g[:2] + '000000', b[:2] + '000000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb2(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[2:4] + '000000', g[2:4] + '000000', b[2:4] + '000000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb3(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[4:6] + '000000', g[4:6] + '000000', b[4:6] + '000000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb4(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[6:] + '000000', g[6:] + '000000', b[6:] + '000000'
        return self._bin_to_int(new_rgb)

    def merge(self, image1, image2, image3, image4):
        # Check the images dimensions
        if image2.size[0] > image1.size[0] or image2.size[1] > image1.size[1]:
            raise ValueError('Image 2 should be smaller than Image 1!')
        if image3.size[0] > image1.size[0] or image3.size[1] > image1.size[1]:
            raise ValueError('Image 3 should be smaller than Image 1!')
        if image4.size[0] > image1.size[0] or image4.size[1] > image1.size[1]:
            raise ValueError('Image 4 should be smaller than Image 1!')

        # Get the pixel map of the two images
        map1 = image1.load()
        map2 = image2.load()
        map3 = image3.load()
        map4 = image4.load()

        new_image = Image.new(image1.mode, image1.size)
        new_map = new_image.load()

        for i in range(image1.size[0]):
            for j in range(image1.size[1]):
                is_valid = lambda: i < image2.size[0] and j < image2.size[1]
                is_valid2 = lambda: i < image3.size[0] and j < image3.size[1]
                is_valid3 = lambda: i < image4.size[0] and j < image4.size[1]
                rgb1 = map1[i, j]
                rgb2 = map2[i, j] if is_valid() else self.BLACK_PIXEL
                rgb3 = map3[i, j] if is_valid2() else self.BLACK_PIXEL
                rgb4 = map4[i, j] if is_valid3() else self.BLACK_PIXEL
                new_map[i, j] = self._merge_rgb(rgb1, rgb2, rgb3, rgb4)

        return new_image

    def unmerge(self, image):
        pixel_map = image.load()

        # Create the new image and load the pixel map
        new_image = Image.new(image.mode, image.size)
        new_map = new_image.load()
        new_image2 = Image.new(image.mode, image.size)
        new_map2 = new_image2.load()
        new_image3 = Image.new(image.mode, image.size)
        new_map3 = new_image3.load()
        new_image4 = Image.new(image.mode, image.size)
        new_map4 = new_image4.load()

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map[i, j] = self._unmerge_rgb1(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map2[i, j] = self._unmerge_rgb2(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map3[i, j] = self._unmerge_rgb3(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map4[i, j] = self._unmerge_rgb4(pixel_map[i, j])

        return [new_image, new_image2, new_image3, new_image4]



class Steganography8:

    BLACK_PIXEL = (0, 0, 0)

    def _int_to_bin(self, rgb):
        if len(rgb) == 4: r, g, b, a = rgb
        else: r, g, b = rgb
        return f'{r:08b}', f'{g:08b}', f'{b:08b}'

    def _bin_to_int(self, rgb):
        r, g, b = rgb
        return int(r, 2), int(g, 2), int(b, 2)

    def _merge_rgb(self, rgb1, rgb2, rgb3, rgb4, rgb5, rgb6, rgb7, rgb8):
        r1, g1, b1 = self._int_to_bin(rgb1)
        r2, g2, b2 = self._int_to_bin(rgb2)
        r3, g3, b3 = self._int_to_bin(rgb3)
        r4, g4, b4 = self._int_to_bin(rgb4)
        r5, g5, b5 = self._int_to_bin(rgb5)
        r6, g6, b6 = self._int_to_bin(rgb6)
        r7, g7, b7 = self._int_to_bin(rgb7)
        r8, g8, b8 = self._int_to_bin(rgb8)
        rgb = r1[:1] + r2[:1] + r3[:1] + r4[:1] + r5[:1] + r6[:1] + r7[:1] + r8[:1],\
              g1[:1] + g2[:1] + g3[:1] + g4[:1] + g5[:1] + g6[:1] + g7[:1] + g8[:1],\
              b1[:1] + b2[:1] + b3[:1] + b4[:1] + b5[:1] + b6[:1] + b7[:1] + b8[:1]
        return self._bin_to_int(rgb)

    def _unmerge_rgb1(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[:1] + '0000000', g[:1] + '0000000', b[:1] + '0000000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb2(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[1:2] + '0000000', g[1:2] + '0000000', b[1:2] + '0000000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb3(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[2:3] + '0000000', g[2:3] + '0000000', b[2:3] + '0000000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb4(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[3:4] + '0000000', g[3:4] + '0000000', b[3:4] + '0000000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb5(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[4:5] + '0000000', g[4:5] + '0000000', b[4:5] + '0000000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb6(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[5:6] + '0000000', g[5:6] + '0000000', b[5:6] + '0000000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb7(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[6:7] + '0000000', g[6:7] + '0000000', b[6:7] + '0000000'
        return self._bin_to_int(new_rgb)

    def _unmerge_rgb8(self, rgb):
        r, g, b = self._int_to_bin(rgb)
        # Extract the last 4 bits (corresponding to the hidden image)
        # Concatenate 4 zero bits because we are working with 8 bit
        new_rgb = r[7:8] + '0000000', g[7:8] + '0000000', b[7:8] + '0000000'
        return self._bin_to_int(new_rgb)

    def merge(self, image1, image2, image3, image4, image5, image6, image7, image8):
        # Check the images dimensions
        if image2.size[0] > image1.size[0] or image2.size[1] > image1.size[1]:
            raise ValueError('Image 2 should be smaller than Image 1!')
        if image3.size[0] > image1.size[0] or image3.size[1] > image1.size[1]:
            raise ValueError('Image 3 should be smaller than Image 1!')
        if image4.size[0] > image1.size[0] or image4.size[1] > image1.size[1]:
            raise ValueError('Image 4 should be smaller than Image 1!')
        if image5.size[0] > image1.size[0] or image5.size[1] > image1.size[1]:
            raise ValueError('Image 5 should be smaller than Image 1!')
        if image6.size[0] > image1.size[0] or image6.size[1] > image1.size[1]:
            raise ValueError('Image 6 should be smaller than Image 1!')
        if image7.size[0] > image1.size[0] or image7.size[1] > image1.size[1]:
            raise ValueError('Image 7 should be smaller than Image 1!')
        if image8.size[0] > image1.size[0] or image8.size[1] > image1.size[1]:
            raise ValueError('Image 8 should be smaller than Image 1!')

        # Get the pixel map of the two images
        map1 = image1.load()
        map2 = image2.load()
        map3 = image3.load()
        map4 = image4.load()
        map5 = image5.load()
        map6 = image6.load()
        map7 = image7.load()
        map8 = image8.load()

        new_image = Image.new(image1.mode, image1.size)
        new_map = new_image.load()

        for i in range(image1.size[0]):
            for j in range(image1.size[1]):
                is_valid = lambda: i < image2.size[0] and j < image2.size[1]
                is_valid2 = lambda: i < image3.size[0] and j < image3.size[1]
                is_valid3 = lambda: i < image4.size[0] and j < image4.size[1]
                is_valid4 = lambda: i < image5.size[0] and j < image5.size[1]
                is_valid5 = lambda: i < image6.size[0] and j < image6.size[1]
                is_valid6 = lambda: i < image7.size[0] and j < image7.size[1]
                is_valid7 = lambda: i < image8.size[0] and j < image8.size[1]
                rgb1 = map1[i, j]
                rgb2 = map2[i, j] if is_valid() else self.BLACK_PIXEL
                rgb3 = map3[i, j] if is_valid2() else self.BLACK_PIXEL
                rgb4 = map4[i, j] if is_valid3() else self.BLACK_PIXEL
                rgb5 = map5[i, j] if is_valid4() else self.BLACK_PIXEL
                rgb6 = map6[i, j] if is_valid5() else self.BLACK_PIXEL
                rgb7 = map7[i, j] if is_valid6() else self.BLACK_PIXEL
                rgb8 = map8[i, j] if is_valid7() else self.BLACK_PIXEL
                new_map[i, j] = self._merge_rgb(rgb1, rgb2, rgb3, rgb4, rgb5, rgb6, rgb7, rgb8)

        return new_image

    def unmerge(self, image):
        pixel_map = image.load()

        # Create the new image and load the pixel map
        new_image = Image.new(image.mode, image.size)
        new_map = new_image.load()
        new_image2 = Image.new(image.mode, image.size)
        new_map2 = new_image2.load()
        new_image3 = Image.new(image.mode, image.size)
        new_map3 = new_image3.load()
        new_image4 = Image.new(image.mode, image.size)
        new_map4 = new_image4.load()
        new_image5 = Image.new(image.mode, image.size)
        new_map5 = new_image5.load()
        new_image6 = Image.new(image.mode, image.size)
        new_map6 = new_image6.load()
        new_image7 = Image.new(image.mode, image.size)
        new_map7 = new_image7.load()
        new_image8 = Image.new(image.mode, image.size)
        new_map8 = new_image8.load()

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map[i, j] = self._unmerge_rgb1(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map2[i, j] = self._unmerge_rgb2(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map3[i, j] = self._unmerge_rgb3(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map4[i, j] = self._unmerge_rgb4(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map5[i, j] = self._unmerge_rgb5(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map6[i, j] = self._unmerge_rgb6(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map7[i, j] = self._unmerge_rgb7(pixel_map[i, j])

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                new_map8[i, j] = self._unmerge_rgb8(pixel_map[i, j])

        return [new_image, new_image2, new_image3, new_image4, new_image5, new_image6, new_image7, new_image8]


class TextSteganographyLayered:

    def str_to_bin(self, s):
        """Convert a string to binary."""
        if type(s) == list: return s
        binary_list = [format(ord(x), 'b').zfill(8) for x in s]
        for x in range(16):
            binary_list.append('00000011') # Add 16 "end of text" bytes to the end of the string
        return binary_list

    def is_ascii(self, s):
        """Check if a string is ASCII."""
        if type(s) == list: return True
        return all(ord(c) < 128 for c in s)

    def div(self, n, x):
        """Check if length of string is divisible by X. If not, add a 0 to it until it is."""
        if len(n) % x == 0: return n
        else: return self.div(n + '0', x)

    def bin_list_to_3_str_list(self, bin_list):
        """Convert a list of binary strings to a string. Then a list of 3 digit binary strings."""
        bin_str = ''.join(bin_list)
        bin_str = self.div(bin_str, 3)
        return [bin_str[i:i + 3] for i in range(0, len(bin_str), 3)]

    def bin_to_str(self, s):
        """Convert a binary string to a string."""
        s = s[:s.index('00000011'*16)]
        return ''.join(chr(int(s[i * 8:i * 8 + 8], 2)) for i in range(len(s) // 8)) # get the text between the start of string and 16 "end of text" bytes

    def _int_to_bin(self, rgb):
        """Convert an integer tuple to binary."""
        if len(rgb) == 4: r, g, b, a = rgb
        else: r, g, b = rgb
        return f'{r:08b}', f'{g:08b}', f'{b:08b}'

    def _bin_to_int(self, rgb):
        """Convert a binary tuple to an integer tuple."""
        r, g, b = rgb
        return int(r, 2), int(g, 2), int(b, 2)

    def _merge_rgb(self, rgb, txt, x):
        """Merge RGB with text. The text is 3 digits long."""
        r1, g1, b1 = self._int_to_bin(rgb)
        rgb = r1[:(8-x)] + txt[0] + r1[(8-x)+1:], g1[:(8 - x)] + txt[1] + g1[(8 - x) + 1:], b1[:(8 - x)] + txt[2] + b1[(8 - x) + 1:]
        return self._bin_to_int(rgb)

    def _decode_rgb(self, rgb, x):
        """Unmerge RGB. Into a 3 digit binary string."""
        r, g, b = self._int_to_bin(rgb)
        return r[(8-x):(8-x+1)] + g[(8-x):(8-x+1)] + b[(8-x):(8-x+1)]

    def encode(self, image, text, layer=1):
        """Encode an image with text. The text must be ASCII."""
        blank_spot = "000"

        # Check if the text will be shorter than image
        if type(text) != list and len(text) > (image.size[0]*image.size[1])*3: raise ValueError('Text is too long for this image.')
        # check if the text is ascii
        if not self.is_ascii(text): raise ValueError('The text must be ASCII.')

        # Get the pixel map of the image
        map1 = image.load()
        # Convert every character in the text to binary and put it in a list
        # Convert the list of binary strings to a list of 3 digit binary strings
        txt_bin_list = self.bin_list_to_3_str_list(self.str_to_bin(text))
        list_len = len(txt_bin_list)

        new_image = Image.new(image.mode, image.size)
        new_map = new_image.load()

        for i in range(image.size[0]):
            for j in range(image.size[1]):
                iteration = (i * image.size[1]) + j
                rgb = map1[i ,j]

                if iteration < list_len: # If the current pixel is valid, use the text. If not, use a blank spot
                    txt = txt_bin_list[iteration]
                else:
                    txt = blank_spot
                new_map[i, j] = self._merge_rgb(rgb, txt, layer)

        bin_list_left = txt_bin_list[image.size[0]*image.size[1]:]
        if len(bin_list_left) > 0:
            new_image = self.encode(new_image, bin_list_left, layer+1)

        return new_image

    def decode(self, image):
        """Decode an image. The image must be merged with this program."""
        pixel_map = image.load()

        layer_list = []
        for layer in range(8):
            binary_list = []
            for i in range(image.size[0]):
                for j in range(image.size[1]):
                    binary_list.append(self._decode_rgb(pixel_map[i, j], layer+1))
            layer_list.append(''.join(binary_list))

        return self.bin_to_str(''.join(layer_list))


class TextToImage:

    def str_to_bin(self, s):
        """Convert a string to binary."""
        binary_list = [format(ord(x), 'b').zfill(8) for x in s]
        for x in range(16):
            binary_list.append('00000011') # Add 16 "end of text" bytes to the end of the string
        return binary_list

    def is_ascii(self, s):
        """Check if a string is ASCII."""
        return all(ord(c) < 128 for c in s)

    def group_by_3(self, lst):
        """Group a list by 3."""
        groups = []
        for i in range(0, len(lst), 3):
            group = lst[i:i + 3]
            while len(group) < 3:
                group.append("00000000")
            groups.append(group)
        return groups

    def get_dimensions(self, area):
        """Get the dimensions of an image with the given area."""
        width = 1
        height = 1
        while width * height < area:
            if width < height:
                width += 1
            else:
                height += 1
        return width, height

    def bin_to_str(self, s):
        """Convert a binary string to a string."""
        return ''.join(chr(int(s[i * 8:i * 8 + 8], 2)) for i in range(len(s) // 8))

    def _int_to_bin(self, rgb):
        """Convert an integer tuple to binary."""
        if len(rgb) == 4: r, g, b, a = rgb
        else: r, g, b = rgb
        return f'{r:08b}', f'{g:08b}', f'{b:08b}'

    def _bin_to_int(self, rgb):
        """Convert a binary tuple to an integer tuple."""
        r, g, b = rgb
        return int(r, 2), int(g, 2), int(b, 2)

    def encode(self, text, mono=False):
        """Create an image from a string."""
        if not self.is_ascii(text): raise ValueError('The text must be ASCII.')


        bin_list = self.str_to_bin(text)
        if not mono: bin_list = self.group_by_3(bin_list)
        list_len = len(bin_list)
        width, height = self.get_dimensions(len(bin_list))

        # Create the image
        image = Image.new("RGB", (width, height))
        # Get the pixel map of the image
        new_map = image.load()


        for i in range(image.size[0]):
            for j in range(image.size[1]):
                iteration = (i * image.size[1]) + j

                if iteration < list_len: # If the current pixel is valid, use the text. If not, use a blank spot
                    if mono: rgb = self._bin_to_int((bin_list[iteration], bin_list[iteration], bin_list[iteration]))
                    else: rgb = self._bin_to_int((bin_list[iteration][0], bin_list[iteration][1], bin_list[iteration][2]))
                else:
                    rgb = self._bin_to_int(("00000000", "00000000", "00000000"))
                new_map[i, j] = rgb

        return image

    def decode(self, image, mono=False):
        """Decode an image. The image must be merged with this program."""
        pixel_map = image.load()
        only_red = True

        bin_list = []
        for i in range(image.size[0]):
            for j in range(image.size[1]):
                binary = self._int_to_bin(pixel_map[i, j])
                if mono:
                    if binary[0] == binary[1] == binary[2]:
                        only_red = False
                    bin_list.append(binary[0])
                else: bin_list.append(binary[0] + binary[1] + binary[2])

        binary = "".join(bin_list)
        if only_red: print("Only red was used. Because the image is not monochrome.")
        return self.bin_to_str(binary[:binary.index('00000011'*16)]) # Remove the "end of text" bytes

